创建型
    工厂方法[beanFactory]、建造者[builder]、抽象工厂、单例和原型模式[object.clone];它们都能够提供对象的创建和管理职责. 
    单例模式要保持内存中只有一个对象.
    原型模式是要求通过复制的方式产生一个新的对象. object.clone() 浅拷贝，(数组，对象引用 只复制引用), 深拷贝 数组对象重新赋值 或者序列化.
         工厂模式VS建造者
            工厂方法模式注重的是整体对象的创建方法,而建造者注重的是部件构造的过程,旨在通过一步一步地精确构造创建出一个复杂的对象.
            举个例子说明两者的差异，如要制造一个超人，如果使用工厂方法模式,直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人,如果使用工厂方法模式,直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；
            而如果使用建造者模式,则需要组装手、脚、躯干等部分,然后把内裤外穿,于是一个超人就诞生了.
            建造者关注的是方法装配和顺序、组合。
        
结构型
     代理模式[AOP]、装饰[IO]、适配、桥接、组合、外观(门面)、享元模式;它们都是通过组合类或对象产生更大结构以适应更高层次的逻辑要求.
         代理模式VS装饰模式
                共同点:具有相同的接口
                不同点:代理模式着重对代理过程控制,装饰着是对类的功能进行加强或减弱,它着重功能变化.
                代理模式就是把当前的行为或功能委托给其他对象执行,代理类负责接口限定:是否可以调用真是角色，以及是否对发送到真实角色消息进行变形处理,它不对主题角色(也就是被代理类)的功能做任何处理,保证原汁原味的调用,
                代理模式适用到极致就是AOP.
                装饰模式是在保证接口不变的情况下加强类的功能,它保证的是被修饰的对象比原始对象丰富或者减弱;但不做准入条件和准入参数的过滤,是否可以执行类的功能,过滤输入参数是否合规等.
          装饰模式VS适配器模式
                共同点：都是包装作用,都是通过委托方式实现其功能。
                不同点：装饰模式包装的是自己的兄弟类,隶属于同一个家族（相同接口或者父类).
                       适配器模式则修饰非血缘关系类,把一个非本家的对象伪装成本家的对象,注意是伪装,因此它的本质还是非相同接口的对象.
            
行为型
     责任链、命令、解释器、迭代、中介者、备忘录、观察者[Listen]、状态、策略、模板方法、访问者模式.
         责任链模式 
         模板方法   基本方法也叫基本操作,是有子类实现的方法，并且在模板方法被调用.
                  模板方法可以有一个或几个,一般是一个具体的方法,也就是一个框架,实现对基本方法的调度完成固定的逻辑.
                    注意:为了防止恶意的操作,一般模板方法都加上final关键字,不允许被覆写.
                        抽象模板中的基本方法尽量设计为protected或private类型，符合【迪米特法则】,不需要暴露的属性或方法尽量不要设置为public.实现类若非必要,尽量不要扩大父类中的访问权限.
         策略模式VS命令模式
             区别：策略模式的意图是封装算法,它认为”算法“已经是一个完整的、不可拆分的原子业务（注意这里是原子业务,而不是原子对象）,即其意图是让这些算法独立，并且可以相互替换，让行为的变化独立于拥有行为的客户；
                  命令模式则是对动作的解耦,把一个动作的执行分为执行对象（接收者角色）、执行行为（命令角色）让两者相互独立而不相互影响。 
         策略模式VS状态模式         
            区别：策略模式封装的是不同的算法,算法之间么有交互,已达到算法的可以自由切换的目的;
                 状态模式封装的是不同的状态,已达到状态切换行为随之发生改变的目的;两者都有变换的行为,但是两者目标却是不同的.
         策略模式VS桥接模式
             策略模式是使用继承和多态建立一套可以自由切换算法的模式
             桥接模式是在不破坏封装的前提下解决抽象和实现都可以独立扩展的模式.桥梁模式必然有两个“桥墩”---抽象化角色和实现化角色,只要桥墩建好，桥就有了,而策略模式只有一个抽象角色,可以没有实现,也可以很多实现.
         门面模式VS中介模式
             门面模式为复杂的子系统提供一个统一的访问界面,它定义的是一个高层接口,该接口使得子系统更加容易使用,避免外部模块深入到子系统内部而产生与子系统内部细节耦合的问题.
             中介模式使用一个中介对象来封装一系列同事对象的交互行为,它使个对象之间不再显示地引用,从而使其耦合松散,建立一个可扩展的应用架构.

模式模式混编[org.example.designPattern.blend]
      命令模式+责任链模式+模板模式
      责任链模式：只要把一个参数传递到链首,就可以立刻获取到一个结果,中间是如何传递的以及有哪些逻辑解析都不需要外界(高层)模块关心.
注解
     annotation package
     https://zhuanlan.zhihu.com/p/60730622
反射
     reflect  package
    